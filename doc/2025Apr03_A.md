### **Step-by-Step Guide to Configuring Serilog in `appsettings.json` in .NET 8 Web API**  

Instead of configuring Serilog in `Program.cs`, we'll move the settings to `appsettings.json` for better maintainability.

---

## **Step 1: Install Required NuGet Packages**  
Run the following command:

```sh
dotnet add package Serilog.AspNetCore
dotnet add package Serilog.Settings.Configuration
dotnet add package Serilog.Sinks.Console
dotnet add package Serilog.Sinks.File
dotnet add package Microsoft.Extensions.Configuration
```

---

## **Step 2: Configure Serilog in `appsettings.json`**  
Modify `appsettings.json` to add Serilog settings:

```json
{
  "Serilog": {
    "Using": ["Serilog.Sinks.Console", "Serilog.Sinks.File"],
    "MinimumLevel": "Information",
    "WriteTo": [
      {
        "Name": "Console"
      },
      {
        "Name": "File",
        "Args": {
          "path": "logs/log-.txt",
          "rollingInterval": "Day",
          "retainedFileCountLimit": 7
        }
      }
    ],
    "Enrich": ["FromLogContext"],
    "Properties": {
      "Application": "SerilogExceptionHandlingDemo"
    }
  }
}
```

- **Console Sink**: Logs output to the terminal.  
- **File Sink**: Logs to `logs/log-YYYY-MM-DD.txt`, rotating daily.  
- **Minimum Level**: `Information` (change to `Debug` or `Verbose` if needed).  
- **Retained File Count Limit**: Keeps only the last 7 log files.  

---

## **Step 3: Modify `Program.cs` to Use Configuration-Based Serilog**
Edit `Program.cs` to read settings from `appsettings.json`:

```csharp
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Diagnostics;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Serilog;
using System;
using System.Text.Json;

var builder = WebApplication.CreateBuilder(args);

// Load Serilog configuration from appsettings.json
builder.Host.UseSerilog((context, config) =>
{
    config.ReadFrom.Configuration(context.Configuration);
});

builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Register Global Exception Handling Middleware
builder.Services.AddTransient<GlobalExceptionHandlingMiddleware>();

var app = builder.Build();

// Use Serilog request logging
app.UseSerilogRequestLogging();

// Middleware for global exception handling
app.UseMiddleware<GlobalExceptionHandlingMiddleware>();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseAuthorization();
app.MapControllers();

app.Run();
```

---

## **Step 4: Create Global Exception Handling Middleware**
Modify **`Middlewares/GlobalExceptionHandlingMiddleware.cs`**:

```csharp
using Microsoft.AspNetCore.Http;
using Serilog;
using System;
using System.Net;
using System.Text.Json;
using System.Threading.Tasks;

public class GlobalExceptionHandlingMiddleware
{
    private readonly RequestDelegate _next;

    public GlobalExceptionHandlingMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task Invoke(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            await HandleExceptionAsync(context, ex);
        }
    }

    private static Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        // Log the exception using Serilog
        Log.Error(exception, "Unhandled exception occurred");

        var response = new { message = "An unexpected error occurred. Please try again later." };

        context.Response.ContentType = "application/json";
        context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;

        return context.Response.WriteAsync(JsonSerializer.Serialize(response));
    }
}
```

---

## **Step 5: Create a Sample Controller to Test Logging**
Modify **`Controllers/TestController.cs`**:

```csharp
using Microsoft.AspNetCore.Mvc;
using Serilog;
using System;

[ApiController]
[Route("api/[controller]")]
public class TestController : ControllerBase
{
    [HttpGet("ok")]
    public IActionResult GetOk()
    {
        Log.Information("TestController: OK endpoint called");
        return Ok(new { message = "API is working fine" });
    }

    [HttpGet("error")]
    public IActionResult GetError()
    {
        throw new Exception("This is a test exception for global handling.");
    }
}
```

---

## **Step 6: Run and Test**
Run the project:

```sh
dotnet run
```

### **Test API Endpoints**
- ‚úÖ `GET http://localhost:5000/api/test/ok` ‚Üí Logs `"TestController: OK endpoint called"` in **console and file**.
- ‚ùå `GET http://localhost:5000/api/test/error` ‚Üí Logs `"Unhandled exception occurred"` and returns:

  ```json
  {
    "message": "An unexpected error occurred. Please try again later."
  }
  ```

- Check `logs/log-YYYY-MM-DD.txt` for logs.

---

## **Best Practices**
‚úÖ **Use appsettings.json for configuration** instead of hardcoding settings in `Program.cs`.  
‚úÖ **Ensure `logs/` directory exists** or handle missing directory errors.  
‚úÖ **Use structured logging** (`.Enrich.FromLogContext()`) to add request details like UserID.  
‚úÖ **Use `Log.Information()`, `Log.Warning()`, and `Log.Error()` properly** instead of `Console.WriteLine()`.  
‚úÖ **Consider using `Serilog.Sinks.Seq`** for real-time log visualization.

---

## **Next Steps**
- Store logs in **SQL Server** or **MongoDB**.
- Add **request tracking** (e.g., correlation ID).
- Use **structured logging** with more context.

üöÄ **Now you have a .NET 8 Web API with Serilog and global exception handling configured in `appsettings.json`!**
